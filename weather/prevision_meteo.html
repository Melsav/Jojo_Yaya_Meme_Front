<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Prévisions Météo</title>
    <link rel="stylesheet" href="style_previsions.css">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Roboto:wght@500&display=swap" rel="stylesheet">
</head>
<body>
    <header>
        <div class="logo-container">
            <div class="logo">
                <img id="logo_site" src="../authent/LOGOO-removebg-preview.png" alt="Logo SkyMétéo">
                <h1 class="site-name">SkyMétéo</h1>
            </div>
        </div>
    </header>

    <img id="sol" src="tonerre.png" alt="icone_sol">
    <img id="lune" src="lune.png" alt="icone_lune">
    <h1 id="titre">Prévisions Météo de la Semaine</h1>

    <div id="body_div">
        

        
        <input type="text" placeholder="Saisir une ville" id="city-input">

        <button id="submit-button" onclick="getForecast()">Obtenir les prévisions</button>

        <div id="forecast-container" class="cadran"></div>
        
    

        <script>
            const apiUrl = "http://localhost:3000";
        
            function fetchWithAuth(url, options = {}) {
                const token = localStorage.getItem('jwtToken');
                const headers = {
                    ...options.headers,
                    'Authorization': token ? `Bearer ${token}` : ''
                };
                return fetch(url, { ...options, headers });
            }
        
            function addToSearchHistory(cityName, weatherDetails) {
                fetch(`${apiUrl}/weather/history`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'Authorization': `Bearer ${localStorage.getItem('jwtToken')}`
                    },
                    body: JSON.stringify({city: cityName, details: weatherDetails}) 
                })
                .then(response => {
                    if (!response.ok) {
                        throw new Error('Erreur lors de l\'enregistrement de la ville et des détails météo dans l\'historique');
                    }
                    console.log('Ville et détails météo ajoutés à l\'historique');
                })
                .catch(error => {
                    console.error('Erreur lors de l\'enregistrement de la ville et des détails météo dans l\'historique', error);
                });
            }
        
            function getForecast() {
                const cityName = document.getElementById('city-input').value;
                const apiKey = 'ae389c751139d10e6c783635a12a3b6e';
        
                fetch(`https://api.openweathermap.org/data/2.5/forecast?q=${cityName}&units=metric&lang=fr&appid=${apiKey}`)
                    .then(response => {
                        if (!response.ok) {
                            throw new Error('Réponse non valide de l\'API OpenWeatherMap');
                        }
                        return response.json();
                    })
                    .then(data => {
                        displayForecast(data); 
                        const tomorrow = new Date();
                        tomorrow.setDate(new Date().getDate() + 1);
                        const indexTomorrow = data.list.findIndex(forecast => {
                            const forecastDate = new Date(forecast.dt_txt);
                            return forecastDate.getDate() === tomorrow.getDate();
                        });
        
                        if (indexTomorrow !== -1) {
                            const details = {
                                temp: data.list[indexTomorrow].main.temp,
                                description: data.list[indexTomorrow].weather[0].description
                            };
                            addToSearchHistory(cityName, details); 
                        }
                    })
                    .catch(error => {
                        console.error('Erreur lors de la récupération des données de prévision', error);
                    });
            }
        
            function displayForecast(data) {
                const forecastContainer = document.getElementById('forecast-container');
                forecastContainer.innerHTML = '';
                const dailyForecasts = groupByDay(data.list);
                const daysToShow = Object.keys(dailyForecasts).slice(1, 6);
                const lavenderColors = ['#4B0082', '#8A2BE2', '#9400D3', '#8A2BE2', '#8A2BE2'];
        
                daysToShow.forEach((day, index) => {
                    setTimeout(() => {
                        const forecastElement = document.createElement('div');
                        forecastElement.classList.add('day-forecast');
                        const averageTemp = calculateAverageTemp(dailyForecasts[day]);
                        forecastElement.style.background = `linear-gradient(to bottom, ${lavenderColors[index % lavenderColors.length]}, ${lavenderColors[(index + 1) % lavenderColors.length]})`;
                        forecastElement.innerHTML = `<strong style="font-size: 1.2em;">${day}</strong><div style="margin-top: 8px;">${dailyForecasts[day][0].weather[0].description}, ${averageTemp} °C</div>`;
                        forecastContainer.appendChild(forecastElement);
                        forecastElement.style.opacity = 1;
                    }, index * 500); 
                });
            }
        
            function groupByDay(forecasts) {
                return forecasts.reduce((grouped, forecast) => {
                    const date = new Date(forecast.dt * 1000);
                    const day = date.toLocaleDateString('fr-FR', { weekday: 'long' });
                    if (!grouped[day]) {
                        grouped[day] = [];
                    }
                    grouped[day].push(forecast);
                    return grouped;
                }, {});
            }
        
            function calculateAverageTemp(forecasts) {
                const totalTemp = forecasts.reduce((sum, forecast) => sum + forecast.main.temp, 0);
                return (totalTemp / forecasts.length).toFixed(1);
            }
        </script>
        
</div>

<button id="next_page" type="button" onclick="redirectToNextPage()">Revenir à l'accueil</button>

    <script>
    console.log("1", localStorage.getItem('jwtToken'))

    function redirectToNextPage() {
        if(localStorage.getItem('jwtToken') != null){
            window.location.href = "../authent/accueil2.html";
        }else{
            window.location.href = "../authent/accueil.html";
        }
    }
    </script>
</body>
</html>
